import json
import os
from typing import Dict, Any, List
import structlog
from datetime import datetime
from pathlib import Path
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

logger = structlog.get_logger(__name__)

class ReportingAgent:
    """
    Agent responsible for generating reports and sending alerts based on analysis results.
    Supports multiple output formats and notification channels.
    """

    def __init__(self, reports_dir: str = "reports", alerts_enabled: bool = True):
        self.reports_dir = Path(reports_dir)
        self.reports_dir.mkdir(exist_ok=True)
        self.alerts_enabled = alerts_enabled

        # Alert thresholds
        self.alert_thresholds = {
            'CRITICAL': True,
            'HIGH': True,
            'MEDIUM': False,
            'LOW': False
        }

    async def generate_report(self, analysis_results: Dict[str, Any],
                            report_type: str = "full") -> Dict[str, Any]:
        """
        Generate comprehensive report from analysis results.

        Args:
            analysis_results: Results from orchestrator
            report_type: Type of report (full, summary, alert)

        Returns:
            Dict containing report metadata and content
        """
        logger.info("Generating report", report_type=report_type)

        try:
            if report_type == "full":
                report_content = self._generate_full_report(analysis_results)
            elif report_type == "summary":
                report_content = self._generate_summary_report(analysis_results)
            elif report_type == "alert":
                report_content = self._generate_alert_report(analysis_results)
            else:
                raise ValueError(f"Unknown report type: {report_type}")

            # Save report
            report_file = self._save_report(report_content, report_type)

            # Send alerts if needed
            if self.alerts_enabled and self._should_alert(analysis_results):
                await self._send_alerts(report_content)

            report_metadata = {
                'report_type': report_type,
                'file_path': str(report_file),
                'generated_at': datetime.utcnow().isoformat(),
                'threat_level': analysis_results.get('overall_threat_level', 'UNKNOWN'),
                'alerts_sent': self.alerts_enabled and self._should_alert(analysis_results)
            }

            logger.info("Report generated successfully", file_path=str(report_file))
            return {
                'metadata': report_metadata,
                'content': report_content
            }

        except Exception as e:
            logger.error("Report generation failed", error=str(e))
            raise

    def _generate_full_report(self, results: Dict[str, Any]) -> str:
        """Generate detailed full report."""
        timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")

        report = f"""
# Databricks Enterprise Security & Network Analysis Report
**Generated:** {timestamp}

## Executive Summary
- **Overall Threat Level:** {results.get('overall_threat_level', 'UNKNOWN')}
- **Analysis Period:** {results.get('metadata', {}).get('hours_back', 'N/A')} hours
- **Analysis Duration:** {results.get('metadata', {}).get('analysis_duration', 'N/A'):.2f} seconds

## Data Summary
- Audit Events Analyzed: {results.get('data_summary', {}).get('audit_events', 0)}
- Active Clusters: {results.get('data_summary', {}).get('clusters', 0)}
- Query Executions: {results.get('data_summary', {}).get('queries', 0)}

## Network Analysis
**Risk Score:** {results.get('network_analysis', {}).get('risk_score', 'N/A')}/10

{results.get('network_analysis', {}).get('network_insights', 'No network insights available')}

### Key Network Findings
{self._format_list(results.get('network_analysis', {}).get('key_findings', []))}

## Security Analysis
**Threat Level:** {results.get('security_analysis', {}).get('threat_level', 'UNKNOWN')}

{results.get('security_analysis', {}).get('security_insights', 'No security insights available')}

### Security Findings
{self._format_list(results.get('security_analysis', {}).get('security_findings', []))}

### Recommended Actions
{self._format_list(results.get('security_analysis', {}).get('recommended_actions', []))}

## Overall Recommendations
{self._format_list(results.get('recommendations', []))}

## Quality Metrics
{self._format_metrics(results.get('metadata', {}).get('quality_metrics', {}))}

---
*Report generated by Databricks Insight Agent*
"""
        return report

    def _generate_summary_report(self, results: Dict[str, Any]) -> str:
        """Generate concise summary report."""
        timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")

        summary = f"""
# Databricks Analysis Summary
**Generated:** {timestamp}

**Threat Level:** {results.get('overall_threat_level', 'UNKNOWN')}
**Events Analyzed:** {results.get('data_summary', {}).get('audit_events', 0)}

## Key Findings
{self._format_list(results.get('network_analysis', {}).get('key_findings', [])[:3])}
{self._format_list(results.get('security_analysis', {}).get('security_findings', [])[:3])}

## Recommendations
{self._format_list(results.get('recommendations', [])[:3])}
"""
        return summary

    def _generate_alert_report(self, results: Dict[str, Any]) -> str:
        """Generate alert-focused report."""
        timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")

        alert = f"""
ðŸš¨ DATABRICKS SECURITY ALERT ðŸš¨
**Time:** {timestamp}
**Threat Level:** {results.get('overall_threat_level', 'UNKNOWN')}

CRITICAL FINDINGS:
{self._format_list(results.get('security_analysis', {}).get('security_findings', []))}

IMMEDIATE ACTIONS REQUIRED:
{self._format_list(results.get('security_analysis', {}).get('recommended_actions', []))}

Network Risk Score: {results.get('network_analysis', {}).get('risk_score', 'N/A')}/10
"""
        return alert

    def _format_list(self, items: List[str]) -> str:
        """Format list items for markdown."""
        if not items:
            return "- No items to report"

        return "\n".join(f"- {item}" for item in items)

    def _format_metrics(self, metrics: Dict[str, float]) -> str:
        """Format quality metrics."""
        if not metrics:
            return "No metrics available"

        return "\n".join(f"- {key}: {value:.2f}" for key, value in metrics.items())

    def _save_report(self, content: str, report_type: str) -> Path:
        """Save report to file."""
        timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
        filename = f"databricks_report_{report_type}_{timestamp}.md"
        filepath = self.reports_dir / filename

        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(content)

        return filepath

    def _should_alert(self, results: Dict[str, Any]) -> bool:
        """Determine if alerts should be sent."""
        threat_level = results.get('overall_threat_level', 'LOW')
        return self.alert_thresholds.get(threat_level, False)

    async def _send_alerts(self, report_content: str):
        """Send alerts via configured channels."""
        logger.info("Sending alerts")

        try:
            # Email alert
            await self._send_email_alert(report_content)

            # Could add Slack, Teams, etc.

        except Exception as e:
            logger.error("Failed to send alerts", error=str(e))

    async def _send_email_alert(self, content: str):
        """Send email alert."""
        # Configuration from environment
        smtp_server = os.getenv('SMTP_SERVER')
        smtp_port = int(os.getenv('SMTP_PORT', 587))
        smtp_user = os.getenv('SMTP_USER')
        smtp_pass = os.getenv('SMTP_PASS')
        alert_recipients = os.getenv('ALERT_EMAILS', '').split(',')

        if not all([smtp_server, smtp_user, smtp_pass, alert_recipients]):
            logger.warning("Email configuration incomplete, skipping email alerts")
            return

        try:
            msg = MIMEMultipart()
            msg['From'] = smtp_user
            msg['To'] = ', '.join(alert_recipients)
            msg['Subject'] = "ðŸš¨ Databricks Security Alert"

            msg.attach(MIMEText(content, 'plain'))

            server = smtplib.SMTP(smtp_server, smtp_port)
            server.starttls()
            server.login(smtp_user, smtp_pass)
            text = msg.as_string()
            server.sendmail(smtp_user, alert_recipients, text)
            server.quit()

            logger.info("Email alert sent successfully", recipients=alert_recipients)

        except Exception as e:
            logger.error("Failed to send email alert", error=str(e))

    async def export_to_json(self, results: Dict[str, Any], filename: str = None) -> str:
        """Export results to JSON file."""
        if not filename:
            timestamp = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
            filename = f"analysis_results_{timestamp}.json"

        filepath = self.reports_dir / filename

        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(results, f, indent=2, default=str)

        logger.info("Results exported to JSON", filepath=str(filepath))
        return str(filepath)